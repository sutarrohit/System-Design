# **Normalization and Denormalization in Databases**

Normalization is **the process of structuring a relational database to reduce redundancy and improve data integrity**. It involves breaking down large tables into smaller, well-organized tables and establishing relationships between them.

âœ… **Goals of Normalization:**

-   **Eliminate data redundancy** (avoid storing duplicate data).
-   **Ensure data integrity** (prevent inconsistencies).
-   **Reduce anomalies** (update, insert, and delete anomalies).
-   **Improve efficiency for updates and maintenance**.

---

## **2. Normal Forms (NF) â€“ Different Levels of Normalization**

Normalization is performed through different levels, known as **Normal Forms (NF)**. Each normal form has stricter requirements than the previous one.

### **ğŸ”¹ 1st Normal Form (1NF) â€“ Eliminate Duplicate Columns**

âœ… **Rules:**

-   **Each column should contain atomic (indivisible) values.**
-   **Each column should contain values of the same type.**
-   **Each row must be unique (with a primary key).**

ğŸš¨ **Example: Unnormalized Table**  
| OrderID | Customer | Products |  
|---------|----------|------------|  
| 101 | John | Laptop, Mouse |  
| 102 | Alice | Keyboard |

ğŸš€ **Convert to 1NF (Atomic Data)**  
| OrderID | Customer | Product |  
|---------|----------|---------|  
| 101 | John | Laptop |  
| 101 | John | Mouse |  
| 102 | Alice | Keyboard |

âœ” Now, each row has atomic values (no comma-separated values).

---

### **ğŸ”¹ 2nd Normal Form (2NF) â€“ Remove Partial Dependency**

âœ… **Rules:**

-   **It must be in 1NF**.
-   **Every non-key column must depend on the entire primary key (not part of it).**

ğŸš¨ **Example: Violation of 2NF**  
| OrderID | ProductID | Customer | ProductName |  
|---------|----------|----------|------------|  
| 101 | P1 | John | Laptop |  
| 101 | P2 | John | Mouse |

âŒ **Problem:** `Customer` depends on `OrderID`, but `ProductName` depends only on `ProductID`, not the full key.

ğŸš€ **Convert to 2NF (Splitting Tables)**

**Orders Table:**  
| OrderID | Customer |  
|---------|----------|  
| 101 | John |  
| 102 | Alice |

**Products Table:**  
| ProductID | ProductName |  
|----------|------------|  
| P1 | Laptop |  
| P2 | Mouse |

**OrderDetails Table (Many-to-Many Relationship):**  
| OrderID | ProductID |  
|---------|----------|  
| 101 | P1 |  
| 101 | P2 |  
| 102 | P3 |

âœ” Now, each column depends entirely on the primary key.

---

### **ğŸ”¹ 3rd Normal Form (3NF) â€“ Remove Transitive Dependency**

âœ… **Rules:**

-   **It must be in 2NF**.
-   **Non-key attributes should not depend on other non-key attributes.**

ğŸš¨ **Example: Violation of 3NF**  
| CustomerID | Name | City | ZipCode | State |  
|------------|------|--------|--------|-------|  
| 1 | John | NYC | 10001 | NY |  
| 2 | Alice| LA | 90001 | CA |

âŒ **Problem:** `City` depends on `ZipCode`, but `ZipCode` is not the primary key.

ğŸš€ **Convert to 3NF (Creating a Separate Table for Zip Codes)**

**Customers Table:**  
| CustomerID | Name | ZipCode |  
|------------|------|--------|  
| 1 | John | 10001 |  
| 2 | Alice| 90001 |

**ZipCodes Table:**  
| ZipCode | City | State |  
|--------|------|-------|  
| 10001 | NYC | NY |  
| 90001 | LA | CA |

âœ” Now, there are no transitive dependencies.

---

## **3. What is Denormalization?**

Denormalization **is the process of combining tables to improve read performance** by reducing the number of joins.

âœ… **Goals of Denormalization:**

-   **Speed up query performance** by reducing joins.
-   **Improve read efficiency** for complex queries.
-   **Reduce overhead from foreign key constraints.**

ğŸš€ **Example: Normalized Database (Slow Reads, Fewer Writes)**

| OrderID | CustomerID |
| ------- | ---------- |
| 101     | 1          |

| CustomerID | Name | Address |
| ---------- | ---- | ------- |
| 1          | John | NYC     |

| OrderID | ProductID |
| ------- | --------- |
| 101     | P1        |

âœ… **Denormalized Table (Faster Reads, More Redundant Data)**  
| OrderID | CustomerName | Address | ProductName |  
|---------|-------------|---------|------------|  
| 101 | John | NYC | Laptop |

âœ” **Faster Reads:** No need for joins.  
âŒ **More Redundant Data:** If John's address changes, multiple rows need updating.

---

## **4. Normalization vs. Denormalization â€“ When to Use?**

| **Factor**            | **Normalization**           | **Denormalization**            |
| --------------------- | --------------------------- | ------------------------------ |
| **Use Case**          | Data integrity, consistency | Fast queries, high performance |
| **Query Speed**       | Slower (joins required)     | Faster (fewer joins)           |
| **Redundancy**        | Low (data stored once)      | High (duplicate data)          |
| **Storage**           | Less                        | More (due to duplication)      |
| **Write Performance** | Better (smaller writes)     | Worse (more data to update)    |
| **Read Performance**  | Slower (joins needed)       | Faster (single table access)   |

ğŸš€ **Use Normalization When:**  
âœ… **Data integrity is critical** (e.g., banking, ERP systems).  
âœ… **Storage is a concern** (reduces duplication).  
âœ… **Data is frequently updated** (avoids inconsistencies).

ğŸš€ **Use Denormalization When:**  
âœ… **Fast read performance is needed** (e.g., analytics, reporting).  
âœ… **Data is mostly read-only** (few updates).  
âœ… **Handling large-scale applications** (big data, caching).

---

## **5. Summary**

ğŸ”¹ **Normalization** â†’ **Reduces redundancy, ensures consistency, improves update performance** but can slow down read queries due to joins.  
ğŸ”¹ **Denormalization** â†’ **Optimizes read performance by reducing joins** but **increases redundancy** and **write complexity**.  
ğŸ”¹ The **best approach** depends on **use case** â€“ transactional systems favor normalization, while **read-heavy applications** (analytics, caching) may benefit from denormalization.
